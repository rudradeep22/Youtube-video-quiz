 About a year ago, I made a tweet that said the dollar sign in Svelte is the most powerful abstraction in modern front-end web development. Usually, I'm not wrong about anything ever, but this tweet ended up aging like a fine milk, because just weeks later, Svelte announced a brand new feature called Runez. That significantly changed the developer experience by eliminating the dollar sign syntax for reactive data. And then just a few days ago, this feature became official with the release of Svelte 5. As an avid user of Svelte myself, I was pretty terrified of this feature at first glance. I was one of the few survivors of the Angular JS to Angular 2 migration. I shot myself in the foot during the React Hooks Revolution, and I lost some good friends during the View Options to Composition transition. And I just can't do the shit anymore, man. So maybe I'll just go back to WordPress. Uh, never mind. Svelte it is. In today's video, we'll find out what the hell a Rune is, and whether or not they're going to ruin Svelt. It is October 24th, 2024, and you're watching the Code Report. Most people really liked Runes when they were first announced. but not everybody.
 I was in denial at first, then I got angry, then I bargained about the trade-offs, then came depression, and finally, I've come to accept and really enjoy runes. The big question is why would the most-loved JavaScript framework make a risky departure from the features people love about it? Like reactive state with Lett and reactive side effects with the dollar sign. Just look at how much nicer this code is compared to React.js. React is even copying spelt with its own compiler to make this code not suck so much. The svelte code is lean and concise, but one could argue that it's almost too clever. Let looks exactly like regular JavaScript, but because Svelt uses a compiler, it doesn't actually work like regular JavaScript. Under the hood, the compiler does some magic to automatically update the UI whenever this value changes. Another issue is that this magic only works in a dot Svelt file, and that means it's difficult to share reactive logic throughout your application. And Svelt created an entirely different API called stores to address that issue. However, Roons fix both of these limitations by A, making your code more explicit, and B, they create a universal reactivity system that can be used. is not only in spilt.
 components, but also in plain JavaScript or TypeScript files. And this dramatically simplifies the overall framework. Like, once you learn these four runes, you'll know about 90% of what you need to know for the framework, because everything else works like normal JavaScript and HTML. Let's go ahead and learn the four major runes now, which you can think of as compiler macros that tells Spelt to do something special that doesn't behave like regular JavaScript or HTML. A state creates a reactive variable that automatically updates the UI when it changes, but under the hood, it's backed by a reactive signal. and replaces the more magical let syntax. Next up, we've got the derived run. This is like use memo in React or computed in view, and it can take a reactive value and compute a new value. It's memoized and will only run when its actual dependencies change, and this replaces the dollar sign colon syntax that I referenced at the beginning of this video. Now, trigger warning, if you use spell to escape from React, this next run is called effect. And just like in React, its purposes to run some code when its dependencies change. It takes a callback function, and if you reference any kind of state, in this callback.
 It will automatically rerun the function whenever that state changes. And this too replaces the dollar sign syntax. And then finally, we have the props run, which eliminates the weird export-let syntax in Svelt and allows you to define inputs to a component. Congratulations, you just learned everything you need to know about the reactivity system. The big question, though, is do these runes ruin Svelt? Well, I recently updated the code in my Svelt Kit course to version 5, and now I'm firmly in the pro-roon camp, although I do sometimes miss the chill vibes of the old syntax. In retrospect, though, my old Svelte code feels very fragile by comparison. If you want to support the channel, check out the full course and become a Fireship Pro member, so I don't have to upload ads ever again and can still put food on my family. What's kind of funny about Svelte 5, though, is that it now looks and feels more like React. Meanwhile, React is starting to look more like Svel. Versel just released NextJ15 this week, and it supports the new React 19 compiler, which eliminates things like Use Memo and makes React feel more like Svel. Angular is also making big moves in this direction with reactive signals, inspired primarily by Solajs,
 And at the bottom of the pool, Vue.js has been doing stuff like this for years without ever getting credit. But everybody stole the idea for reactive signals from the long-forgotten knockout JS. You really can't go wrong choosing a JavaScript framework in 2024 because they're all the same thing. And that's a good thing. This has been the code report. Thanks for watching, and I will see you in the next one.
